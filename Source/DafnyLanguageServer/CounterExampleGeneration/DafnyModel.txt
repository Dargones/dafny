// Copyright by the contributors to the Dafny Project
// SPDX-License-Identifier: MIT

/*#nullable disable
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Text.RegularExpressions;
using Microsoft.BaseTypes;
using Microsoft.Boogie;

namespace Microsoft.Dafny.LanguageServer.CounterExampleGeneration {

  /// <summary>
  /// A wrapper around Boogie's Model class that allows extracting
  /// types and values of Elements representing Dafny variables. The three core
  /// methods are: GetDafnyType, DatatypeConstructorName, and GetExpansion
  /// </summary>
  public class DafnyModel {
    public readonly List<string> LoopGuards;
    private readonly DafnyOptions options;
    public readonly Model Model;
    public readonly List<PartialState> States = new();

    public static readonly UserDefinedType UnknownType =
      new(new Token(), "?", null);

    private readonly int tyArgMultiplier;
    private readonly ModelFuncWrapper fBox, fUnbox;

    public DafnyModel(Model model, DafnyOptions options) {
      LoopGuards = new List<string>();
      Model = model;
      this.options = options;
      tyArgMultiplier = options.TypeEncodingMethod switch {
        CoreOptions.TypeEncoding.Arguments => 1,
        _ => 0
      };
      fBox = new ModelFuncWrapper(this, "$Box", 1, tyArgMultiplier);
      fUnbox = new ModelFuncWrapper(this, "$Unbox", 2, 0);
      foreach (var s in model.States) {
        var sn = new PartialState(this, s);
        States.Add(sn);
        sn.loopGuards = LoopGuards.ToList();
        if (sn.FullStateName.Contains("after some loop iterations")) {
          LoopGuards.Add("loopGuard" + LoopGuards.Count);
          sn.isGuard = LoopGuards.Last();
        }
      }
    }

    /// <summary>
    /// Extract and parse the first Dafny model recorded in the model view file.
    /// </summary>
    public static DafnyModel ExtractModel(DafnyOptions options, string mv) {
      const string begin = "*** MODEL";
      const string end = "*** END_MODEL";
      int beginIndex = mv.IndexOf(begin, StringComparison.Ordinal);
      int endIndex = mv.IndexOf(end, StringComparison.Ordinal);
      var modelString = mv.Substring(beginIndex, endIndex + end.Length - beginIndex);
      var model = Model.ParseModels(new StringReader(modelString)).First();
      return new DafnyModel(model, options);
    }

    public IEnumerable<PartialValue> GetExpansion(PartialState state, PartialValue value) {
      foreach (var function in Model.Functions) {
        switch (function.Name) {
          case "Seq#Length":
            // TODO: Handle a situation in which there exist element indices that are larger that the specified length
            var fSeqLength =  new ModelFuncWrapper(this, function.Name, 1, tyArgMultiplier);
            var lengthFunctionTuple = fSeqLength.AppWithArg(0, value.Element);
            if (lengthFunctionTuple == null) {
              break;
            }
            var lengthValue = PartialValue.Get(lengthFunctionTuple.Result, state);
            lengthValue.AddDefinition(new UnaryOpExpr(Token.NoToken, UnaryOpExpr.Opcode.Cardinality, value.ElementIdentifier), new() { value }, new());
            yield return lengthValue;
            break;
          case "Seq#Build":
            var fSeqBuild = new ModelFuncWrapper(this, function.Name, 2, tyArgMultiplier);
            if (fSeqBuild.AppWithResult(value.Element) == null) {
              break;
            }
            var substring = value.Element;
            List<PartialValue> elements = new();
            while (fSeqBuild.AppWithResult(substring) != null) {
              elements.Insert(0, PartialValue.Get(Unbox(fSeqBuild.AppWithResult(substring).Args[1]), state));
              substring = fSeqBuild.AppWithResult(substring).Args[0];
            }
            for (int i = 0; i < elements.Count; i++) {
              var index = new LiteralExpr(Token.NoToken, i);
              index.Type = Type.Int;
              var lengthConstraint = value.AddConstraint(new BinaryExpr(Token.NoToken, BinaryExpr.Opcode.Gt, new UnaryOpExpr(Token.NoToken, UnaryOpExpr.Opcode.Cardinality, value.ElementIdentifier), index), new() { value });
              elements[i].AddDefinition(new SeqSelectExpr(
                  Token.NoToken,
                  true,
                  value.ElementIdentifier,
                  index,
                  null,
                  Token.NoToken),
                new() { value, elements[i] }, new List<Constraint>() { lengthConstraint });
              yield return elements[i];
            }
            value.AddDefinition(
              new SeqDisplayExpr(Token.NoToken,
                elements.ConvertAll(element => element.ElementIdentifier as Expression)), elements, new());
            break;
        }
      }
    }
    

    /// <summary> Unboxes an element, if possible </summary>
    private Model.Element Unbox(Model.Element elt) {
      if (elt == null) {
        return null;
      }
      var unboxed = fBox.AppWithResult(elt);
      if (unboxed != null) {
        return Unbox(unboxed.Args[0]);
      }
      unboxed = fUnbox.AppWithArg(1, elt);
      return unboxed != null ? Unbox(unboxed.Result) : elt;
    }
  }
}*/
